

命題:
	apacheの/server-statusのW, Rなどのステータスはどのような時点でのステータスなのか、生存範囲について調査する。


調査: 参考ソース(httpd-2.2.27)

/server-statusにアクセスした際に処理されているファイルは以下のファイル
	modules/generators/mod_status.c

以下の処理で内部的に格納されたscoreboardからデータを取得し、格納しているようだ。
332         ps_record = ap_get_scoreboard_process(i);
333         for (j = 0; j < thread_limit; ++j) {
334             int indx = (i * thread_limit) + j;
335 
336             ws_record = ap_get_scoreboard_worker(i, j);
337             res = ws_record->status;
338             stat_buffer[indx] = status_flags[res];
339 


status_flagには以下のような値が格納される
840     status_flags[SERVER_DEAD] = '.';  /* We don't want to assume these are in */
841     status_flags[SERVER_READY] = '_'; /* any particular order in scoreboard.h */
842     status_flags[SERVER_STARTING] = 'S';
843     status_flags[SERVER_BUSY_READ] = 'R';
844     status_flags[SERVER_BUSY_WRITE] = 'W';
845     status_flags[SERVER_BUSY_KEEPALIVE] = 'K';
846     status_flags[SERVER_BUSY_LOG] = 'L';
847     status_flags[SERVER_BUSY_DNS] = 'D';
848     status_flags[SERVER_CLOSING] = 'C';
849     status_flags[SERVER_GRACEFUL] = 'G';
850     status_flags[SERVER_IDLE_KILL] = 'I';

scoreboardが取得される関数ap_get_scoreboard_processが存在するところにscoreboard関連の処理が記述されているだろうと推測して、
ap_get_scoreboard_processでgrepをかけてみます。
server/scoreboard.cを調べてみます。
513 AP_DECLARE(process_score *) ap_get_scoreboard_process(int x)
514 {
515     if ((x < 0) || (server_limit < x)) {
516         return(NULL); /* Out of range */
517     }
518     return &ap_scoreboard_image->parent[x];
519 }

今度はap_scoreboard_image->parentをセットしている箇所を見つけます。「ap_scoreboard_image->parent」で同じファイルをgrepします。
以下の３つの関数で上記配列に値がセットされていることがわかります。
(2)は生成時に初期化しているだけですので、(1)と(3)に着目します。

# (1)
116 void ap_init_scoreboard(void *shared_score)

# (2)
269 int ap_create_scoreboard(apr_pool_t *p, ap_scoreboard_e sb_type)

# (3)
422 AP_DECLARE(int) ap_update_child_status_from_indexes(int child_num,
423                                                     int thread_num,
424                                                     int status,
425                                                     request_rec *r)


(3)は同ファイル中のap_update_child_statusメソッドにより呼び出されています。
ソースファイル全体をap_update_child_statusやap_update_child_status_from_indexesでgrepをかけると
例えば以下のように呼び出されている箇所があります。
./server/core.c:3953:    (void)ap_update_child_status(c->sbh, SERVER_BUSY_READ, (request_rec *)NULL);

上記のSERVER_BUSY_READの定義はinclude/scoreboard.hに下記定義がありました。
 58 #define SERVER_DEAD 0
 59 #define SERVER_STARTING 1>--/* Server Starting up */
 60 #define SERVER_READY 2>->---/* Waiting for connection (or accept() lock) */
 61 #define SERVER_BUSY_READ 3>-/* Reading a client request */
 62 #define SERVER_BUSY_WRITE 4>/* Processing a client request */
 63 #define SERVER_BUSY_KEEPALIVE 5>/* Waiting for more requests via keepalive */
 64 #define SERVER_BUSY_LOG 6>--/* Logging the request */
 65 #define SERVER_BUSY_DNS 7>--/* Looking up a hostname */
 66 #define SERVER_CLOSING 8>---/* Closing the connection */
 67 #define SERVER_GRACEFUL 9>--/* server is gracefully finishing request */
 68 #define SERVER_IDLE_KILL 10     /* Server is cleaning up idle children. */
 69 #define SERVER_NUM_STATUS 11>---/* number of status settings */


SERVER_BUSY_READを検索する。mod_status.cが含まれるgeneratorsディレクトリを除いてgrepしてみる。
$ grep  -rinH SERVER_BUSY_READ ./* --exclude-dir=generators
./include/scoreboard.h:61:#define SERVER_BUSY_READ 3	/* Reading a client request */
./modules/http/http_core.c:136:        ap_update_child_status(c->sbh, SERVER_BUSY_READ, NULL);
./modules/http/http_core.c:182:    ap_update_child_status(c->sbh, SERVER_BUSY_READ, NULL);
./server/mpm/netware/mpm_netware.c:757:        case SERVER_BUSY_READ:
./server/core.c:3953:    (void)ap_update_child_status(c->sbh, SERVER_BUSY_READ, (request_rec *)NULL);


SERVER_BUSY_WRITEを検索する。mod_status.cが含まれるgeneratorsディレクトリを除いてgrepしてみる。
$ grep  -rinH SERVER_BUSY_READ --exclude-dir=generators
modules/http/http_core.c:136:        ap_update_child_status(c->sbh, SERVER_BUSY_READ, NULL);
modules/http/http_core.c:182:    ap_update_child_status(c->sbh, SERVER_BUSY_READ, NULL);
include/scoreboard.h:61:#define SERVER_BUSY_READ 3	/* Reading a client request */
server/mpm/netware/mpm_netware.c:757:        case SERVER_BUSY_READ:
server/core.c:3953:    (void)ap_update_child_status(c->sbh, SERVER_BUSY_READ, (request_rec *)NULL);


続いて、WRITEもみてみる。
$ grep  -rinH SERVER_BUSY_WRITE --exclude-dir=generators
modules/http/http_core.c:143:            ap_update_child_status(c->sbh, SERVER_BUSY_WRITE, r);
modules/http/http_core.c:188:        ap_update_child_status(c->sbh, SERVER_BUSY_WRITE, r);
include/scoreboard.h:62:#define SERVER_BUSY_WRITE 4	/* Processing a client request */
server/mpm/netware/mpm_netware.c:760:        case SERVER_BUSY_WRITE:


READとWRITEを見たところ以下の２箇所の関数でREADとWRITE共に呼び出されていることが確認できます。
	124 static int ap_process_http_async_connection(conn_rec *c)
	172 static int ap_process_http_connection(conn_rec *c)

これら２箇所の関数は同ファイル中のregister_hooks関数で呼ばれていて、非同期対応のMPMを設定している場合にはasyncの方を、そうでない場合には別の方を呼び出すようになっていると思われる。

単純な同期メソッド　ap_process_http_connectionの方を確認するものとする。


####　余談: register_hooksの呼び出し元について
modules/http/http_core.cで呼び出されるregister_hooks関数は、同ファイル中の以下で定義されている。
280 module AP_MODULE_DECLARE_DATA http_module = {
281     STANDARD20_MODULE_STUF,
282     NULL,              /* create per-directory config structure */
283     NULL,              /* merge per-directory config structures */
284     NULL,              /* create per-server config structure */
285     NULL,              /* merge per-server config structures */
286     http_cmds,         /* command apr_table_t */
287     register_hooks     /* register hooks */
288 };

http_moduleという変数はmodules.cで定義されている。

register_hooksはserver/config.cのap_register_hooksという関数名で呼ばれている
 422 AP_DECLARE(void) ap_register_hooks(module *m, apr_pool_t *p)
 423 {
 424     if (m->register_hooks) {
 425         if (getenv("SHOW_HOOKS")) {
 426             printf("Registering hooks for %s\n", m->name);
 427             apr_hook_debug_enabled = 1;
 428         }
 429 
 430         apr_hook_debug_current = m->name;
 431         m->register_hooks(p);
 432     }
 433 }

ap_register_hooksはserver/config.cの下記関数で呼ばれている。
 497 AP_DECLARE(const char *) ap_add_module(module *m, apr_pool_t *p)

 ap_add_moduleは同じファイルの以下の関数で呼ばれているが、特に影響となる処理で呼ばれてなさそう。
  606 AP_DECLARE(const char *) ap_add_loaded_module(module *mod, apr_pool_t *p)

ap_register_hooksが呼ばれていないかを再度確認してみたところはserver/main.cの以下で呼ばれている。
	699             ap_register_hooks(*mod, pconf);

つまり、WRITEはserver/main.cの699行目が呼び出された際に記録される。
694     for (;;) {
695         apr_hook_deregister_all();
696         apr_pool_clear(pconf);
697 
698         for (mod = ap_prelinked_modules; *mod != NULL; mod++) {
699             ap_register_hooks(*mod, pconf);
700         }
701 


なお、modules/http/http_core.cのap_process_http_connectionの定義に戻ります。
READとWRITEは以下のように定義されているようです。
ap_read_requestの処理の前にREAD、その処理が完了したらWRITEと設定しているようです。
172 static int ap_process_http_connection(conn_rec *c)
173 {
174     request_rec *r;
175     apr_socket_t *csd = NULL;
176 
177     /*
178      * Read and process each request found on our connection
179      * until no requests are left or we decide to close.
180      */
181 
182     ap_update_child_status(c->sbh, SERVER_BUSY_READ, NULL);       /*** ここでREAD ***/
183     while ((r = ap_read_request(c)) != NULL) {
184 
185         c->keepalive = AP_CONN_UNKNOWN;
186         /* process the request if it was read without error */
187 
188         ap_update_child_status(c->sbh, SERVER_BUSY_WRITE, r);     /*** ここでWRITE ***/
189         if (r->status == HTTP_OK)
190             ap_process_request(r);
191 


では、ap_read_requestとは一体なんなんでしょうか
server/protocol.cにその関数ロジックが記述されていました(300行ほどの長い処理)

ap_read_requestやっている処理としては以下のような内容でした。
	* r構造体生成
	* リクエストの読み込み
	* リクエストタイムアウトのチェック
	* バーチャルホストのチェック
	* Expectヘッダチェック
	* HTTPプロトコルバージョンのチェック
	* etc...
