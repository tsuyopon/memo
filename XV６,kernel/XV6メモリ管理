
###########################################################################
メモリ管理概要
###########################################################################
*** 参考
この辺を参考にするといいかもしれない。
	http://www.nminoru.jp/~nminoru/programming/arch/virtual_memory.html
	http://softwaretechnique.jp/OS_Development/kernel_development07.html

###########################################################################
メモリ状況確認コマンド
###########################################################################
*** 便利コマンド
$ ps aux | sort -r -k4 
$ top
$ free -m
$ vmstat -Sm 1 10
$ cat /proc/meminfo
$ cat /proc/slabinfo
$ sudo slabtop
$ sar


vmstatの見方: http://piro791.blog.so-net.ne.jp/2008-10-02

*** ベンチマークなどを実行している場合にキャッシュを綺麗さっぱりにする方法
$ sync
# echo 3 > /proc/sys/vm/drop_caches

値の意味としては下記の通り
    1： ページキャッシュを解放
    2： dentry、inode を解放
    3： ページキャッシュ、dentry、inode を解放


###########################################################################
基礎概念
###########################################################################
*** メモリ階層構造
以下の４階層に分けています。
	(4) Linuxのメモリ管理システムを使う他のコンポーネント
	(3) スラブアロケータ
			kmem_cache_alloc()
			kmem_cache_free()
			kmalloc()
			kfree()
		動的空間割り当て
			vmalloc()
			vfree()
			kmap()
			kunmap()
	(2) ページアロケータ
			ページ単位の管理(get_free_pages等)
			連続領域
			２のべき乗(buddy)システム
	(1) ハードウェア


*** アドレス概念
仮想メモリの中心的な仕事は、「仮想アドレス」を「物理アドレス」に変換することにあり、これをページングと呼びます。

メモリ理解のために以下の４つのアドレス概念を押さえておきます。
	論理アドレス: ユーザープロセスから見たときにロード・ストア命令で直接指定するアドレス。要はプログラムから指定するアドレスです。
	仮想アドレス: ページングを行う前のアドレス。ユーザー空間とカーネル空間の２つに分けられているようです。
	実アドレス:   ページングを行った後のアドレス(リニアアドレスとも呼ばれる)。論理アドレス + α(セグメントレジスタ)という修正を受けたもの
	物理アドレス: 物理的な実体を持っていてメモリバスで指定できるアドレス

続いて、アーキテクチャによって論理アドレスと仮想アドレスの関係は以下のようになります。
	論理アドレス＝仮想アドレスの場合:                System/370、SPARC、MIPS、Alpha
	論理アドレスから仮想アドレスへの変換が必要な場合:  IA-32、AMD64、PowerPC、PA-RISC、IA-64
	ページング機能(MMU)が無効な場合、リニアアドレスが実際のメモリアドレスである物理アドレスになります。

*** アドレス変換用語
論理アドレスから仮想アドレスへの変換を、Segmentation Spacing Regioningという。
仮想アドレスから実アドレスへの変換を、Pagingという。
実アドレスから物理アドレスへの変換を、Prefixingという。

- ページング詳細
	ページングは固定サイズのページを単位に仮想アドレスから物理アドレスへの変換を行う。
	ページサイズがpビットの場合、仮想アドレスmビットの上位 m - p ビットが仮想ページ番号(Virtual Page Number: VPN)となる。
	実アドレスがnビットの場合には、上位 n - p ビットがPhysical Page Number(PPN)またはPage Frame Number(PFN)となる。
	ページングはVPNからPPNへの変換を行い、ページ内のオフセットアドレスはそのまま適用される。

(参考) http://wiki.bit-hive.com/north/pg/%A5%A2%A5%C9%A5%EC%A5%B9%B6%F5%B4%D6%A4%CE%B8%C6%BE%CE%A4%CB%A4%C4%A4%A4%A4%C6

*** アドレス変換例
例えば、変換としてIA-16(8080)を考えて見る。
直接行えるメモリアドレスは16bit(これが論理アドレスに相当)。
別にセグメントレジスタと呼ばれる16bit幅のレジスタ群があり、メモリアクセスはセグメントレジスタのどれかによって修飾されて実行されていた。
実際にアクセスされるメモリアドレスは
	(セグメントレジスタ) X 16 + (オフセットアドレス)
によって合成される。


###########################################################################
用語定義
###########################################################################
*** 仮想メモリ方式
仮想メモリ機構として主に使用されているのが以下の２つの機構です。
	セグメンテーション機構
		メモリをセグメントの呼ばれる開始位置とそのサイズを自由に変更することができる方式

	ページング機構
		メモリを固定長のページに分割してメモリを管理する方式

現在ではページング機構の方が一般的なようなので、このページではこちらで解説します。


*** MMU
MMUはCPU内部に存在する仮想アドレスを物理アドレスに変換する機能です。
http://ja.wikipedia.org/wiki/%E3%83%A1%E3%83%A2%E3%83%AA%E7%AE%A1%E7%90%86%E3%83%A6%E3%83%8B%E3%83%83%E3%83%88

MMUはTLB制御も行ってくれる。
	http://en.wikipedia.org/wiki/Memory_management_unit#mediaviewer/File:MMU_principle_updated.png

*** TLB(Translation Lookaside Buffer)とは
TLBはCPUナイブニ存在する機能です。
論理物理変換の際に、毎回毎回ページテーブルを参照していては遅くて仕方ないので、よく使われる変換テーブルをCPU内部にTLBキャッシュします。
一般的にはCPUには有限個(64, 128程度)のTLBエントリが用意されていて、TLB領域のアクセスについてはページテーブルにアクセスせずに高速にアクセスできます。
一度に幅広い領域をアクセスするようなプログラムの場合には、頻繁にTLBミスが起きるので性能が低下することになります。

（参考URL) wikipedia
	http://ja.wikipedia.org/wiki/%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B9%E3%83%AC%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%83%BB%E3%83%AB%E3%83%83%E3%82%AF%E3%82%A2%E3%82%B5%E3%82%A4%E3%83%89%E3%83%BB%E3%83%90%E3%83%83%E3%83%95%E3%82%A1


*** TLBとDDR	について

関係性は以下のようになっています。TLBは一般的にCPUに包括されるらしいが、以下では便宜上、分離して記述している。
+----------+      +-----+      +----------------+      +------+
| CPU(MMU) | <--> | TLB | <--> | DDR Controller | <--> | DRAM |
+----------+      +-----+      +----------------+      +------+

TLBとDDR Controller間には以下の３つのバスが存在し、これを使ってやりとりしています。
	アドレスバス
		メモリアドレス信号を出力するために使われる線。使われる線の本数をアドレスバス幅と言う。
		メモリのアドレスや入出力装置(I/O)のアドレスが出力される。
		データのやり取りを行う場合、データの取り出し先、あるいはデータの格納先を指定する必要がある、この場所を指定するのがアドレスバス。
	データバス
		CPUと、メモリやI/Oとの間でデータを転送するために使われるバス。
		指定された場所に格納されているデータを扱う。
		やり取りされるデータは、演算するための数値やその演算結果、外部機器からの入力信号や外部機器に出力する信号など。
	コントロールバス
		これらの各バスを制御するバス制御用バス
		アドレスバスやデータバスで実際に入出力を行うタイミングや、その他CPUと外部との間での必要な制御情報をやり取りする信号バス。
		アドレスバスで指定された場所に対して、読み出しを行うのか、書き込みを行うかを指定する。
		アドレスバスで指定されたメモリやI/Oは、コントロールバスにより書き込みを指示された場合は、データバスで送られて来たデータを受け取る。
		コントロールバスにより読み出しを指示された場合は、データバスにデータを取り出す。


*** ページテーブルとは
論理物理変換用の仮想アドレスと物理アドレスの対応表です。
IA-32の場合には、このページテーブルはPGD（Page Global Directory: ページディレクトリとも呼ばれる), PTEといった２段階構成になっていて、特定のレジスタにPGDの物理アドレスを書き込むだけで論理物理変換についてはCPUが面倒
を見てくれます。

*** ページフレーム番号(PFN: Page Frame Number)
物理アドレスが何ページ目かを示す数値でとなっている。
例えば、1ページが4KByteとして物理アドレス0x00000000のPFNは0x0、物理アドレス0x00001000のPFNは0x1、0x12345000のPFNは0x12345となります。

*** 仮想マッピング
ある仮想空間に対して特定の物理アドレスを対応づけることを仮想マップするといいます。
仮想マッピングは一般にページテーブルの特定のエントリ(ページテーブルエントリ、PTE)に対応する物理アドレスを書き込むことで実現される。

*** CR3レジスタ
ページディレクトリテーブルのアドレスをCPUにセットするためのレジスタとしてCR3レジスタが用意されています。
CPU内のCR3レジスタはPGDテーブルを指します。

*** PAE(Physical Address Extension)
PentinumPro以降はアドレスバスが36本に増えている。つまり、2^36 = 64GBのメモリをアドレス付けできる。
32bit CPUで36bitアドレスバスを利用するには32bitリニアアドレスを36bit物理アドレスに変換する新しいページング機構が必要。これがPAE


***
仮想アドレスのうち、上位は、MMU (MMU) により変換する。
仮想アドレスのうち、下位(ページサイズ分)は、そのままメモリに送られる。 
	http://www.coins.tsukuba.ac.jp/~yas/coins/os2-2010/2011-01-25/


*** ページテーブルを使って仮想アドレスから物理アドレスを探索する仕組み
ページディレクトリテーブルのアドレスをCPUにセットするためのレジスタとしてCR3レジスタが用意されています。MMUは仮想メモリ空間へのアクセスに対してCR3レジスタに書かれたページディレクトリテーブルのアドレスへアクセスして探索を行います。探索を行う時、仮想アドレスの先頭10ビットをページディレクトリテーブルへのオフセットとしてページテーブルを指すエントリを探索します。

ページテーブルでは仮想アドレスの11～20ビットをオフセットとして物理ページを指すエントリを探索します。見つかった物理ページのアドレスに対して仮想アドレスの残り12ビットの値を足したアドレスが、CPUがアクセスしようとしている物理アドレスとなります。

ページディレクトリテーブルは1024個の配列(1つの配列をPDEという)
ページテーブルも1024個の配列(1つの配列をPTEという)


(参考)
	http://d.hatena.ne.jp/yohei-a/20140501/1398921610

	http://softwaretechnique.jp/OS_Development/kernel_development08.html


*** ユーザー空間とカーネル空間での分離
一般的なOSでは4GBのメモリ空間の最初の2GB（または3GB）をユーザ空間、後ろの2GB（または3GB）をカーネル空間として分けています。
ユーザ空間のPTEとPDEにはユーザ特権を、カーネル空間のPTEとPDEにはスーパーバイザ特権を割り当てることでユーザ空間で実行中のプロセスはカーネル空間にアクセスできないようにします。

Linuxであれば図のように0x00000000から0xBFFFFFFFの3GBをユーザ空間として、また0xC0000000から0xFFFFFFFFの1GBをカーネル空間として割り当てています。

*** TLBをフラッシュする
LBは仮想メモリアドレスを物理メモリアドレスに変換するキャッシュを持っていました。
自動的にキャッシュしてくれますが、ページディレクトリを変更した直後はページががらりと変わってしばらくの間はキャッシュが役に立たない（TLBミスばかりする）状況となります。
このような場合に、手動でTLBをフラッシュ（現在のキャッシュを捨てる）することができます
TLBをフラッシュするにはINVLPG命令を使用します。
TLBをフラッシュする関数を用意しておきます

###########################################################################
解釈
###########################################################################

論理アドレス: ユーザープロセスから見たときにロード・ストア命令で直接指定するアドレス。要はプログラムから指定するアドレスです。
	$ objdump -f a.out　を実行した際に表示されるアドレスは実際に実行を始める仮想メモリのアドレスとなっています。

仮想アドレス: ページングを行う前のアドレス。ユーザー空間とカーネル空間の２つに分けられているようです。


リニアアドレス(実アドレス):   ページングを行った後のアドレス(リニアアドレスとも呼ばれる)。論理アドレス + α(セグメントレジスタ)という修正を受けたもの
	http://ascii.jp/elem/000/000/567/567932/img.html
		31-22bit:	ページディレクトリへのオフセット(a)
		22-12bit:   ページテーブルへのオフセット(b)
		11-0bit:    オフセット(c)

	CR3に入っているページディレクトリのベースアドレスと(a)を加算して、そのページディレクトリのエントリにアクセスすることができる。

	リニアアドレスから物理アドレスの変換方法について
		http://d.hatena.ne.jp/yz2cm/20140502/1399029253

物理アドレス: 物理的な実体を持っていてメモリバスで指定できるアドレス





(参考)
	リニアアドレス -> 物理アドレスの変換方式
		http://d.hatena.ne.jp/yz2cm/20140502/1399029253
	インテルアーキテクチャーのページング
		http://caspar.hazymoon.jp/OpenBSD/annex/intel_paging.html
	ページング方式(wikipedia)
		http://ja.wikipedia.org/wiki/%E3%83%9A%E3%83%BC%E3%82%B8%E3%83%B3%E3%82%B0%E6%96%B9%E5%BC%8F



####### 要調査
*** 疑問：論理アドレス、仮想アドレス、リニアアドレスが全て同じことを指している文献を見るけど本当なのか?
*** ユーザー空間とカーネル空間のメモリの違いはどのように実現されているのか?
*** ユーザー、カーネルのお互いが不可侵としている仕組みが知りたい
*** スラブアロケーターって何者?
*** buddyシステムって何者
*** dentryとかって何?
