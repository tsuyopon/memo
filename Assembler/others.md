未整理関連

# x86系(8086)アセンブラ
### アセンブラの基礎構造
```
	.file   "ファイル名.s"
	.data					#ここに変数の定義を書く
	#データを書く
	.text   				#ここから実行文が始まる
	.globl main			    #はじめに呼び出される関数を.globlで指定（globalではなくglobl)
	main:
	        # 命令を書く　
```

### Hello World
```
	$ vim helloworld.s
	.file   "helloworld.s"
	.data
	msg:    .ascii  "hello world\n"
	msgend: .equ    len, msgend - msg

	.globl main
	main:
	        movl $4,        eax    # write system call(sys_write)
	        movl $1,        ebx    # stdout
	        movl $msg,      ecx
	        movl $len,      edx
	        int  $0x80
	        ret

	$ gcc helloworld.s -o hw
	$ ./hw
```

eaxレジスタにsys_writeシステムコールを設定、引数が３つあるのでebxレジスタに出力先の標準出力を意味する$1を設定する。  
第二引数にメッセージのデータ$msgを設定、第三引数にメッセージの長さの$lenを設定、最後にシステムコールのint $0x80を実行してシステムコールを呼び出している。  
またその次の行のretオペコードはreturnをあらわしこれによりプログラムが終了される。  

### ニーモニック
命令のことをニーモニックという。ニーモニックは、OPコード(オペコード)とオペランド(operand)のことをいう。
```
    movb $0x01 %al
```
上記の例では、移動する命令のmovbがOPコード 、１６進数の数値の$0x01とレジスタを意味する%alをオペランドという。


### オペコード
4004などの8bitCPUは、8bit(1byte)での処理を行っていたので、オペコードで8bitを処理をするにはbyteを意味するbをつける。
```
	movb $0xff %ah
	movb $0xff %al
```

8086などの16bitCPUは、eXtend(拡張)を意味するレジスタを利用し、オペコードで16bitを処理するには16bitを意味するwordのwをつける。
```
	movw $0x01ff %ax
```

386やPentiumなどの32bitCPUは、Extend(拡張)を意味するレジスタを利用し、オペコードで32bitを処理するには32bitを意味するlongのlをつける。
```
	movl $0x123401ff %eax
```

これでハローワールドのmovオペコードの意味が理解できたと思う．また数値は$記号ではじまり、レジスタは%記号で始まる。




### C言語との連動(x86拡張インラインアセンブリ)

x86拡張インラインアセンブリは以下の構文で表すことができます。
```
	asm(アセンブリテンプレート : 出力オペランド : 入力オペランド : 破壊されるレジスタのリスト)
```

この構文を用いると任意のレジスタをCの変数として書き出したり、Cの任意の変数の内容を任意のレジスタに設定した上でアセンブリ処理を行うことができるようになります。

##### サンプル1
例えば、
```
	asm(
	    "movl $0x01, %eax;"
	    "addl $0x05, %eax"
	);
```
は処理が終わった後にはeaxは0x06となっています。  

このeaxに設定された足し算結果をCの変数に格納したいような場合には拡張構文を使って以下のように記述できます。
```
	int result;
	asm(
	    "movl $0x01, %%eax;"
	    "addl $0x05, %%eax"
	    : "=a" (result)
	);
```
ここでは前半のmovlやaddlまでを「アセンブリテンプレート」、:以降が「出力オペランド」となります。  
構文の「入力オペランド」と「破壊されるレジスタのリスト」は使わないので省略しています。  

これにより"=a" (result)は「アセンブリ処理の最後にeaxに設定された値をresultという変数に書き出せ」という指令になります。  


##### サンプル2)
サンプル１とは異なり入力オペランドも含めた事例としてサンプル2を確認します。

```
	int x = 1, y = 5;
	int result;
	asm(
	    "movl %2, %%eax;"
	    "addl %1, %%eax"
	    : "=a" (result)
	    : "m" (x), "m" (y)
	);
```

「"m" (x), "m" (y)」が入力オペランドの指定です。  
メモリ中にx, yを設定し、その値をインラインアセンブリの中から指定できるようにしています。  
アセンブリテンプレート中の%1、%2が入出力オペランドに指定した値を参照するための指示詞  
```
	%0: result
	%1: x
	%2: y
```

上記のコードはeaxを経由せずに計算しないようにすれば、もう少し短くすることができます。
```
	int x = 1, y = 5;
	asm(
	    "addl %2, %0;"
	    : "=r" (x)
	    : "0" (x), "m" (y)
	);
```

この場合のポイントとしては
```
	xは入出力兼用
	入力オペランド"0"というのはアセンブリテンプレート内で %0 と同等の意味を持ちます。このように記述することでxが入出力兼用であることを指定しています。
	これによって、%0がx、%2がyで結果はxに出力するという準備が整いました。
```

- 参考資料
 - http://d.hatena.ne.jp/naoya/20070924/1190653790

### "=a"や"=r"などについての意味
"Constraint and Modifier"などで検索すると表示される。

この辺の資料を参考にすると良い
- https://gcc.gnu.org/onlinedocs/gcc/Constraints.html

### x86のConstraint and Modifier
上記の続き。

Constraintsは次の通り
```
"a"       eax
"b"       ebx
"c"       ecx
"d"       edx
"s"       esi
"D"       edi
"I"       0～31までの定数 for 32 bit shifts
"J"       0～63までの定数 for 64 bit shifts
"K"       定数0xff
"L"       定数0xffff
"M"       0,1,2,3のうちの定数 (shifts for `lea')
"N"       0～255までの定数 (`out'命令向け)
"G"       80387標準浮動小数点定数
"q"       自動割り当て(eax,ebx,ecx,edxの中から)
"r"       自動割り当て(eax,ebx,ecx,edx,esi,ediの中から)
"g"       eax,ebx,ecx,edx もしくは許される凡ゆるアドレスのメモリ
"m"       許される凡ゆるアドレスのメモリ
"A"       eaxとedxを合わせて64bitのlong long型で使う。
"f"       数値浮動小数点レジスタの中から自動割り当て
"t"       浮動小数点スタックの先頭の数値浮動小数点レジスタ
"u"       浮動小数点スタックの2番目の数値浮動小数点レジスタ
"0","1","2",...       入出力オペランド部分で割り当てられたレジスタやメモリを割り当てられた順に指す。
```

Modifier Charactersは次の通り
```
=   書き込み専用を意味し、以前の値を消して、asm文のアセンブリ部分で書き込まれた値を持つようにする。
+   読み書き両用を意味する。　
&   そのオペランドが、入力オペランドの使用が終わる前に破損することに対して適切に対処する。すなわち、そのオペランドをインプット用のレジスタやメモリから切り離すことで、入力オペランドが壊れたレジスタに影響されることを防ぐ。
```

### .bssとは
Block Started by Symbolの略称
- http://www.ertl.jp/~takayuki/readings/info/no03.html
- http://ja.wikipedia.org/wiki/.bss

ELFでは以下のように定義
	このセクションには、プログラムが使うメモリのうち、初期化されていないデータ(変数)が入っています。  
	定義では、システムはプログラムを走らせる前に、ゼロで初期化しないといけません。  
	このセクションは、SHT_NOBITSというセクション種別が示すように、ファイル内にデータを持ちません。  

.bssに格納されるもの
- 初期値を持たない大域変数
- 初期値が0の大域変数
- 初期値を持たない静的局所変数
- 初期値が0の静的局所変数

レジスタ
- eax 	汎用レジスタ
- ebx 	汎用レジスタ
- ecx 	汎用レジスタ
- edx 	汎用レジスタ

命令
- mov 	代入 	mov (値) (代入先)
- int 	割り込み 	int (番号)

命令
- movb 	1byteの値を代入
- movw 	2byteの値を代入
- movl 	4byteの値を代入

##### 加算
```
	MOV EAX, 13 
	MOV EBX, 4
	ADD EAX, EBX （←EAXにEBXの値を足しなさい）
```

##### 減算
```
	MOV EAX, 13 
	MOV EBX, 4
	SUB EAX, EBX （←EAXからEBXの値を引きなさい）
```

##### 乗算
```
	MOV EAX, 13 
	MOV EBX, 4
	MUL EBX      （←EAXにEBXの値を掛けなさい）
```

##### 除算
```
	MOV EAX, 13 
	MOV EBX, 4
	MOV EDX, 0
	DIV EBX      （←EAXをEBXの値で輪って、商をEAXに、余りをEDXに入れなさい）
```

