# 目的
xv6ソースコードで次の処理を確認しておきます。
- システムコールはどのように登録されているか?
- どのようにユーザー空間から実行されているか?

# 詳細

### システムコールの初期化、登録の全体像

mainの中でIDTテーブルを初期化処理する箇所(A)と、IDTテーブルを登録する箇所(B)の処理を抜粋した。
```
main {
    ...
    tvinit();                          // (A) ここでIDTテーブル(Interrupt Descriptor Table)の初期化処理を行なう
    ...

    mpmain();
        ...
        idtinit();
            lidt(idt, sizeof(idt));    // (B) ここでIDTテーブルをLIDT命令を使って登録する。
        ...
}
```


### (A)の処理
(A)については次のようにL23でidt[0]からidt[255]番までの登録を行なっている。ここで入ってくるvecors
その後、L27において80の番号だけは上書きして登録されており、ここで特に第２引数と第４引数の値がL23と異なることに着目する。

- 第２引数については、trapをセットしています。(TODO: ここのtypeについてはいくつかあるので後日調査)
- 第４引数についてはDPL(Descriptor Privilege Level)というカーネルの特権レベルを表している。80番だけはDPL_USER(=3)が指定されていて、その他は全て0となっている。つまりLinuxではRing0(カーネル), Ring3(アプリケーション)であるがxv6もそれを踏襲している。

ここにあるvectors配列はハンドラを仕掛けている。このvectorsがどのように設定されているのかはあとで詳しく見ていくことにするが、ここでは一旦おいておく。

```
 17 void
 18 tvinit(void)
 19 { 
 20   int i;
 21   
 22   for(i = 0; i < 256; i++)
 23     SETGATE(idt[i], 0, SEG_KCODE<<3, vectors[i], 0);  // ここで定義されるvectorsはvectors.Sで定義されているようだ
 24   
 25   // システムコールで80だけ上書きされる。この場合上記と違って第２引数と第４引数が異なる。
 26   // 第２引数はtrapであることを示していて、第３引数は特権レベルを指定するDPL_USER=3(アプリケーション)となっている。
 27   SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);  // T_SYSCALLは16進数で64なので、10進数で80である。
 28   
 29   initlock(&tickslock, "time");
 30 } 
```

上記のL23, L27で登場するSETGATEは、次のようにidt[i]のオブジェクトに対してデータを登録している。
```
// mmu.h
205 // Set up a normal interrupt/trap gate descriptor.
206 // - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate.
207 //   interrupt gate clears FL_IF, trap gate leaves FL_IF alone 
208 // - sel: Code segment selector for interrupt/trap handler
209 // - off: Offset in code segment for interrupt/trap handler
210 // - dpl: Descriptor Privilege Level -
211 //        the privilege level required for software to invoke
212 //        this interrupt/trap gate explicitly using an int instruction.
213 #define SETGATE(gate, istrap, sel, off, d)                \
214 {                                                         \
215   (gate).off_15_0 = (uint)(off) & 0xffff;                \
216   (gate).cs = (sel);                                      \
217   (gate).args = 0;                                        \
218   (gate).rsv1 = 0;                                        \
219   (gate).type = (istrap) ? STS_TG32 : STS_IG32;           \
220   (gate).s = 0;                                           \
221   (gate).dpl = (d);                                       \
222   (gate).p = 1;                                           \
223   (gate).off_31_16 = (uint)(off) >> 16;                  \
224 } 
```

上記でデータをしているidt[i]はgatedesc構造体であり、定義は次のものを表している。
```
// mmu.h
 11 // Interrupt descriptor table (shared by all CPUs).
 12 struct gatedesc idt[256];
 ...
191 // PAGEBREAK: 12
192 // Gate descriptors for interrupts and traps
193 struct gatedesc {
194   uint off_15_0 : 16;   // low 16 bits of offset in segment
195   uint cs : 16;         // code segment selector
196   uint args : 5;        // # args, 0 for interrupt/trap gates
197   uint rsv1 : 3;        // reserved(should be zero I guess)
198   uint type : 4;        // type(STS_{TG,IG32,TG32})
199   uint s : 1;           // must be 0 (system)
200   uint dpl : 2;         // descriptor(meaning new) privilege level
201   uint p : 1;           // Present
202   uint off_31_16 : 16;  // high bits of offset in segment
203 };
204 
```

### vectors配列
idt[i]を初期化した際にSETGATEを呼び出していた際の第３引数でvectors[i]といった配列を渡していましたが、これはどこで定義されているのかを確認します。

これは実はvectors.plというスクリプトで作成されます。Makefileでビルドした際にvectors.Sとして生成します。
```
135 vectors.S: vectors.pl
136     perl vectors.pl > vectors.S
```

生成されたvectors.Sは次のような値となります。
L1279以降で.dataとしてvectorsを定義していますので、これが配列となります。
```
   1 # generated by vectors.pl - do not edit
   2 # handlers
   3 .globl alltraps
   4 .globl vector0
   5 vector0:
   6   pushl $0
   7   pushl $0
   8   jmp alltraps
   9 .globl vector1
  10 vector1:
  11   pushl $0
  12   pushl $1
  13   jmp alltraps
  14 .globl vector2
  15 vector2:
  16   pushl $0
  17   pushl $2
  18   jmp alltraps
...
1277 
1278 # vector table
1279 .data
1280 .globl vectors
1281 vectors:
1282   .long vector0
1283   .long vector1
1284   .long vector2
...
```

システムコール番号が呼ばれたら最初に0をpushlして、その後システムコール番号をpushlしてから、jmp alltrapsでalltraps関数に飛びます。
alltrapsはtrapasm.Sで定義されています。L23でtrap関数を呼び出しています。

```
// trapasm.S 
  1 #include "mmu.h"
  2 
  3   # vectors.S sends all traps here.
  4 .globl alltraps
  5 alltraps:
  6   # Build trap frame.
  7   pushl %ds
  8   pushl %es
  9   pushl %fs
 10   pushl %gs
 11   pushal
 12 
 13   # Set up data and per-cpu segments.
 14   movw $(SEG_KDATA<<3), %ax
 15   movw %ax, %ds
 16   movw %ax, %es
 17   movw $(SEG_KCPU<<3), %ax
 18   movw %ax, %fs
 19   movw %ax, %gs
 20 
 21   # Call trap(tf), where tf=%esp
 22   pushl %esp
 23   call trap
 24   addl $4, %esp
```

trap関数が呼ばれると次の関数が呼ばれる。
この関数ではtf->trapnoの値に応じてシステムコールかどうか、IRQ呼び出しかどうかなどが判断されてそれに応じた処理が実行されます。
L42-L49ではシステムコール番号が呼ばれた場合の処理が記述されています。
```
// trap.c
 39 void
 40 trap(struct trapframe *tf)
 41 {
 42   if(tf->trapno == T_SYSCALL){
 43     if(proc->killed)
 44       exit();
 45     proc->tf = tf;
 46     syscall();
 47     if(proc->killed)
 48       exit();
 49     return;
 50   }
 51 
 52   switch(tf->trapno){
 53   case T_IRQ0 + IRQ_TIMER:
...
```

上記のシステムコールが呼ばれた時のメイン処理L46を追いかけてみることにします。
syscall関数は次の定義となっていて、L133でその実体がよばれてそうです。
```
126 void
127 syscall(void)
128 {   
129   int num;
130   
131   num = proc->tf->eax;
132   if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
133     proc->tf->eax = syscalls[num]();
134   } else {
135     cprintf("%d %s: unknown sys call %d\n",
136             proc->pid, proc->name, num);
137     proc->tf->eax = -1;
138   } 
139 }  
```

L133で呼び出されるのはnumの値に応じた関数となります。
```
102 static int (*syscalls[])(void) = {
103 [SYS_fork]    sys_fork,
104 [SYS_exit]    sys_exit,
105 [SYS_wait]    sys_wait,
106 [SYS_pipe]    sys_pipe,
107 [SYS_read]    sys_read,
108 [SYS_kill]    sys_kill,
109 [SYS_exec]    sys_exec,
110 [SYS_fstat]   sys_fstat,
111 [SYS_chdir]   sys_chdir,
112 [SYS_dup]     sys_dup,
113 [SYS_getpid]  sys_getpid,
114 [SYS_sbrk]    sys_sbrk,
115 [SYS_sleep]   sys_sleep,
116 [SYS_uptime]  sys_uptime,
117 [SYS_open]    sys_open,
118 [SYS_write]   sys_write,
119 [SYS_mknod]   sys_mknod,
120 [SYS_unlink]  sys_unlink,
121 [SYS_link]    sys_link,
122 [SYS_mkdir]   sys_mkdir,
123 [SYS_close]   sys_close,
124 }; 
```

上記のSYS_xxxは次の箇所でシステムコール番号が定義されています。
```
// syscall.c
  1 // System call numbers
  2 #define SYS_fork    1
  3 #define SYS_exit    2
  4 #define SYS_wait    3
  5 #define SYS_pipe    4
  6 #define SYS_read    5
  7 #define SYS_kill    6
  8 #define SYS_exec    7
  9 #define SYS_fstat   8
...
```

たとえば、fstatが呼ばれる場合にはSYS_fstatは8番で、その時の関数ポインタはsys_fstatを指します。
では、sys_fstatはどこにあるのでしょうか? それはusys.Sの中でdefineされています。

```
// usys.S
  1 #include "syscall.h"
  2 #include "traps.h"
  3 
  4 #define SYSCALL(name) \
  5   .globl name; \
  6   name: \
  7     movl $SYS_ ## name, %eax; \
  8     int $T_SYSCALL; \
  9     ret
 10 
 11 # syscall.hに$SYS_fork, $SYS_exit等の番号は定義されている
 12 SYSCALL(fork)
 13 SYSCALL(exit)
 14 SYSCALL(wait)
 15 SYSCALL(pipe)
 16 SYSCALL(read)
 17 SYSCALL(write)
 18 SYSCALL(close)
 19 SYSCALL(kill)
 20 SYSCALL(exec)
 21 SYSCALL(open)
 22 SYSCALL(mknod)
 23 SYSCALL(unlink)
 24 SYSCALL(fstat)
```

```
// syscall.c
 25 // These are arbitrarily chosen, but with care not to overlap
 26 // processor defined exceptions or interrupt vectors.
 27 #define T_SYSCALL       64      // system call
```

上記L24でSYSCALL(fstat)が定義されているので、L4-L9のdefineに当てはめるとアセンブラで直接fstatという名前の関数が定義されていることがわかりました。
```
.globl fstat
fstat: 
  movl $SYS_fstat, %eax;   // $SYS_fstatは先のdefineより8番
  int $T_SYSCALL;          // $T_SYSCALLは16進数で64(10進数で80)
  ret
```

なお、syscall関数からsys_fstatが呼ばれた場合には次のロジックが呼ばれることになります。
```
103 int 
104 sys_fstat(void)
105 {   
106   struct file *f;
107   struct stat *st;
108 
109   if(argfd(0, 0, &f) < 0 || argptr(1, (void*)&st, sizeof(*st)) < 0)
110     return -1;
111   return filestat(f, st);
112 }
```

### (B)の処理
(A)で初期化されたidt[i]配列はどのように登録されているかというと、CPU上のLIDT命令を用いて登録しています。
```
 81 static inline void
 82 lidt(struct gatedesc *p, int size)  // lidt = Load Intterupt Descripter Table
 83 {   
 84   volatile ushort pd[3];
 85   
 86   pd[0] = size-1;
 87   pd[1] = (uint)p;
 88   pd[2] = (uint)p >> 16;
 89   
 90   asm volatile("lidt (%0)" : : "r" (pd));
 91 }
```

### アプリケーション空間からどのようにシステムコールが呼び出されているのか?

先ではfstatを呼び出すと%eaxをセットしてint 64を実行する部分がアセンブラで定義するところまでを確認しました。
では、アプリケーションからどのように利用されているのかを見てみることにします。


たとえば、ライブラリのstat関数の中でfstatを呼び出していたり、
```
 70 int
 71 stat(char *n, struct stat *st)
 72 {
 73   int fd;
 74   int r;
 75 
 76   fd = open(n, O_RDONLY);
 77   if(fd < 0)
 78     return -1;
 79   r = fstat(fd, st);
 80   close(fd);
 81   return r;
 82 }
```

また、lsコマンドはシステムコールにはありませんが、実は内部的にはopen(L33)やfstat(L38)のシステムコールを組み合わせることで処理を実現しています。
```
 25 void
 26 ls(char *path)
 27 {
 28   char buf[512], *p;
 29   int fd;
 30   struct dirent de;
 31   struct stat st;
 32 
 33   if((fd = open(path, 0)) < 0){
 34     printf(2, "ls: cannot open %s\n", path);
 35     return;
 36   }
 37 
 38   if(fstat(fd, &st) < 0){
 39     printf(2, "ls: cannot stat %s\n", path);
 40     close(fd);
 41     return;
 42   }
...
```

以上によって、アプリケーションからは単純にシステムコールとしてのコマンドを実行するだけでIDTで登録された処理を実行することがわかりました。


# まとめ
システムコールは次のような方法で初期化、登録、実行までが行われていることを確認しました。
- IDT配列で割り込みとして実行する際に必要なハンドラを定義する。この定義はアセンブラから処理が始まっていることが確認できました。
- IDT配列として必要なハンドラを初期化する。そこでは命令を実行可能な特権レベルやtrapかどうかを決定する
  - SETGATEのdefineにDPL_USERを指定することによって、リングプロテクションの仕組みを用いることができるようになる。
- 上記のIDTをLIDT命令を通じて登録する
- アプリケーションからはfstatなどを呼ぶことで、内部的にはINT 64命令を発行しています。

