# Overview
Appendix E.  Backward Compatibilityについて
- https://tools.ietf.org/html/rfc5246#appendix-E

# 詳細

### E.1 TLS 1.0/1.1 と SSL 3.0 との互換性
TLS(1.0, 1.1, 1.2, any future version)とSSL(2.0, 3.0)には様々なバージョンが存在しているので、特定のプロトコルバージョンをネゴシエーションするための手段が必要とされている。
TLSプロトコルは、バージョン選択の煩雑さで他のプロトコルを困らせることがないように、バージョンネゴシエーションに対しての組み込みメカニズムを提供しています。

TLSバージョン1.0, 1.1, 1.2, SSL3.0は非常に似通っています。そして、互換性のあるClientHelloメッセージを利用します。
これによって、全てのバージョンのサポートを比較的簡単に行っています。
同様にして、サーバはClientHelloフォーマットが互換性が残されている限り、TLSが新しいバージョンを使うことを簡単に扱うことが出来ます。

他の古いバージョンとネゴシエーションしたいTLS1.2のクライアントは、標準的な{3,3}(TLS1.2)をclient_version中に含むTLS1.2 ClientHelloのフォーマットを送信します。
もしクライアントがこのバージョンを使用すると同意したならば、ネゴシエーションは適切に処理されます。

サーバによって選ばれたバージョンがクライアントによってサポートされていなかったり、受け入れられなかった場合には、クライアントはprotocol_versionアラートを送って、コネクションをクローズしなければなりません。

もしTLSサーバがサーバによってサポートされる最も高いバージョンよりも大きなバージョンを含むClientHelloを受け取ったら、サーバによってサポートされる最も高いバージョンを返答しなければなりません。

TLSサーバは最も高いバージョンよりも低いバージョンを含んだClientHelloを受け取ることも可能です。もしサーバが古いクライアントとネゴシエーションしたかったら、サーバによってサポートされる最も高いバージョン(そのバージョンはClientHello.client_versionよりも大きくない)が適切として処理を続けるでしょう。

たとえば、もしサーバがTLS1.0, 1.1, 1.2をサポートしていて、client_versionがTLS1.0ならば、サーバはTLS1.0として処理をすすめるでしょう。
もしサーバがclient_versionよりも大きなバージョンだけしかサポートしていなかったら、サーバはprotocol_versionアラートメッセージを送り、コネクションをクローズしなければなりません。

クライアントがすでに最も高いバージョンを知っているときには(例えば、セッションを再開する場合)、ネイティブプロトコルでコネクションをイニシエートしなければならない。(TODO)
- Whenever a client already knows the highest protocol version known to a server 

注意: いくつかのサーバ実装はバージョンネゴシエーションが不適切として知られています。
たとえば、クライアントがTLS1.0よりも新しいバージョンを提供しようとした際に、単純に接続を閉じるだけのバグなTLS1.0サーバもあります。
また、幾つかのサーバはClientHello中にTLS拡張が含まれていたら接続を拒否するということも知られています。
このようにバグがあるサーバとの相互運用性はこのドキュメントの範疇を超える煩雑なトピックであり、クライアントによって複数回のコネクション試行を必要とするかもしれません。

TLS仕様の初期バージョンはClientHelloを送付する際にレコードレイヤーのバージョン番号(TLSPlaintext.version)が含まれるべきかといったことが完全にクリアになっていませんでした。
この仕様に準拠するTLSサーバはClientHelloのレコードレイヤーのバージョン番号として{03,XX}のどんな値でも受け付けなければなりません。


古いサーバとネゴシエーションしたいTLSクライアントは、レコードレイヤーのバージョン番号として{03,XX}のどんな値でも送ってくるかもしれません。
クライアントによってサポートされる最も低いバージョン番号の典型的な値は{03,00}となるでしょう。

1つの値では全ての古いサーバとの相互運用性を保証されません。 しかし、これはどのドキュメントの範疇を超える煩雑なトピックです。(TODO)


### E.2 SSL2.0との互換性
省略...



### E.3 バージョンロールバックによる中間者攻撃を回避する
TLSクライアントがVersion2.0互換性モードにフォールバックする際に、特別なPKCS#1ブロックフォーマットを利用しなければならない(?)
これによってTLSサーバがTLS2.0が可能なクライアントをリジェクトすることになるでしょう。

クライアントがSSL2.0でネゴシエートするとき(しかし、TLSもサポートする)、クライアントは最下位8ランダムバイトのPKCS paddingを付与しなければなりません。
そのパディングはCLIENT-MASTER-KEYのENCRYPTED-KEY-DATAフィールドの中のRSA暗号化


TLS可能なサーバがSSL2.0をネゴシエートする際に、サーバはこれらの8つのpaddingが0x03のバイトであることをチェックするべきである。
もしそうじゃなかったら、サーバはENCRYPTED-KEY-DATAを解読したあとにSECRET-KEY-DATAのためにランダム値を生成すべきである。そして、ハンドシェイクを継続するべきである。

クライアントへのエラー状況は[BLEI]リンクに述べられている通りにサーバ脆弱性となりうる点があることに注意すること。

# SeeAlso
- https://www.ipa.go.jp/security/rfc/RFC2246-AEJA.html



